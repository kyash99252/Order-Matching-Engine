package com.example.exchange.core.matching;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.NavigableMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.example.exchange.core.orderbook.OrderBook;
import com.example.exchange.domain.Order;
import com.example.exchange.domain.Side;
import com.example.exchange.domain.Trade;

/**
 * The core matching engine.
 * Design Principle (Separation of Concerns): This class contains ONLY the matching logic. It has no knowledge of
 * databases, APIs, or Spring. It takes an order, processes it against the current order book, and produces a list of trades.
 * It is highly cohesive and has low coupling.
 *
 * It is thread-safe, using a lock per symbol to ensure that orders for the same symbol are processed sequentially,
 * which is critical for maintaining data integrity in a concurrent environment.
 */
@Component
public class MatchingEngine {
    
    private static final Logger log = LoggerFactory.getLogger(MatchingEngine.class);

    // In-memory store for all order books, one per symbol
    private final ConcurrentHashMap<String, OrderBook> orderBooks = new ConcurrentHashMap<>();
    // A lock for each symbol to ensure serial processing of orders for the same symbol
    private final ConcurrentHashMap<String, ReentrantLock> symbolLocks = new ConcurrentHashMap<>();

    /**
     * The main entry point for processing a new order.
     * It finds the correct order book, acquires a lock for that symbol, and attempts to match the order.
     *
     * @param newOrder The new order to be processed.
     * @return A list of trades generated by this order. The list is empty if no match occurred.
     */
    public List<Trade> processOrder(Order newOrder) {
        // Get or create the lock and order book for the symbol
        ReentrantLock lock = symbolLocks.computeIfAbsent(newOrder.getSymbol(), k -> new ReentrantLock());
        OrderBook book = orderBooks.computeIfAbsent(newOrder.getSymbol(), OrderBook::new);

        lock.lock();
        try {
            log.info("Processing order {} for symbol {}", newOrder.getId(), newOrder.getSymbol());
            List<Trade> trades = new ArrayList<>();

            // Match a sell order against bids
            // Match a buy order against asks
            if (newOrder.getSide() == Side.BUY) {
                match(trades, newOrder, book.getAsks());
            } else {
                match(trades, newOrder, book.getBids());
            }

            // If the order is not fully filled, add it to the order book
            if (newOrder.getRemainingQuantity().compareTo(BigDecimal.ZERO) > 0) {
                book.addOrder(newOrder);
                log.info("Added partially filled or unfilled order {} to the book with remaining quantity {}", newOrder.getId(), newOrder.getRemainingQuantity());
            }

            return trades;
        } finally {
            lock.unlock();
        }
    }

    /**
     * The core matching algorithm.
     * Iterates through the resting orders of the opposite side and creates trades if prices match.
     *
     * @param trades          The list to add any generated trades to.
     * @param incomingOrder   The new order being processed.
     * @param restingOrders   The opposite side of the book to match against.
     */
    private void match(List<Trade> trades, Order incomingOrder, NavigableMap<BigDecimal, Deque<Order>> restingOrders) {
        // Iterate through the price levels of the opposite side
        for (var entry: restingOrders.entrySet()) {
            Deque<Order> ordersAtPrice = entry.getValue();

            // Check if a match is possible
            boolean isMatchPossible = (incomingOrder.getSide() == Side.BUY && incomingOrder.getPrice().compareTo(entry.getKey()) >= 0) || (incomingOrder.getSide() == Side.SELL && incomingOrder.getPrice().compareTo(entry.getKey()) <= 0);

            if (!isMatchPossible) {
                break;
            }

            // Iterate through orders at this price level
            var iterator = ordersAtPrice.iterator();
            while (iterator.hasNext()) {
                Order restingOrder = iterator.next();
                BigDecimal tradeQuantity = incomingOrder.getRemainingQuantity().min(restingOrder.getRemainingQuantity());

                // Create the trade. The execution price is the price of the resting order
                Trade trade = createTrade(incomingOrder, restingOrder, restingOrder.getPrice(), tradeQuantity);
                trades.add(trade);
                log.info("Generated Trade: {}", trade);

                // Update the quantities of both orders
                incomingOrder.setRemainingQuantity(incomingOrder.getRemainingQuantity().subtract(tradeQuantity));
                restingOrder.setRemainingQuantity(restingOrder.getRemainingQuantity().subtract(tradeQuantity));

                // If the resting order is fully filled, remove it
                if (restingOrder.getRemainingQuantity().compareTo(BigDecimal.ZERO) == 0) {
                    iterator.remove();
                }

                // If the incoming order is fully filled, we are done
                if (incomingOrder.getRemainingQuantity().compareTo(BigDecimal.ZERO) == 0) {
                    return;
                }
            }
        }
    }

    private Trade createTrade(Order incomingOrder, Order restingOrder, BigDecimal price, BigDecimal quantity) {
        if (incomingOrder.getSide() == Side.BUY) {
            return new Trade(incomingOrder.getSymbol(), incomingOrder.getId(), restingOrder.getId(), price, quantity);
        } else {
            return new Trade(incomingOrder.getSymbol(), restingOrder.getId(), incomingOrder.getId(), price, quantity);
        }
    }

    /**
     * Retrieves the current order book for a symbol.
     * @param symbol The symbol to look up.
     * @return The order book, or null if it doesn't exist.
     */
    public OrderBook getOrderBook(String symbol) {
        return orderBooks.get(symbol);
    }
}
